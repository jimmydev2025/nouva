(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6814],{49441:e=>{"use strict";e.exports={getGlobalPrivyAuthUrl:()=>"https://auth.privy.io"}},43392:(e,r,t)=>{"use strict";t.d(r,{A:()=>w});var a=t(49441),o=t(39907);let i="cla04x0d00002nyb6oofp5dqh",n=o.env.VERCEL_GIT_COMMIT_SHA,s="pk_live_51IVGUtF66LfGv8cgubvAHN9hcEUMJJOvprWKjAUEhuWCQsQZHGE5b1PDzChVsiIjyCOCbmqpgtH9cQAemzTIuG3600x1ub2mo9",c="J64Bl2g14xIjQ0Vp6Xo0lPPu1oIdFx2G6yg6bVGgihA=";if("string"!=typeof i)throw Error("NEXT_PUBLIC_PRIVY_APP_ID needs to be defined");let d=(0,a.getGlobalPrivyAuthUrl)(),l="https://dashboard.privy.io";if(!l||"string"!=typeof l)throw Error("NEXT_PUBLIC_DASHBOARD_PRIVY_AUTH_URL must be defined");let u="https://dashboard.privy.io";u||console.warn("No Privy dashboard URL found, some dashboard admin actions like reporting to Slack will not work.");let y="4df5e2316331463a9130964bd6078dfa",v="fe9c30fc-3bc5-4064-91e2-6ab5887f8f4d";if("string"!=typeof y)throw Error("NEXT_PUBLIC_PRIVY_INFURA_ID must be set");if("string"!=typeof v)throw Error("NEXT_PUBLIC_PRIVY_BLAST_ID must be set");if("string"!=typeof s)throw Error("NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY must be set");if("string"!=typeof c)throw Error("NEXT_PUBLIC_DELEGATED_ACTIONS_TEE_PUBLIC_KEY must be set");let w=Object.freeze({isTest:!1,isProduction:!0,isStaging:!1,isDevelopment:!1,PRIVY_APP_ID:i,PRIVY_ENV:"production",GLOBAL_PRIVY_AUTH_URL:d,DASHBOARD_PRIVY_AUTH_URL:l,DASHBOARD_URL:u,PRIVY_INFURA_ID:y,PRIVY_BLAST_ID:v,GIT_COMMIT_SHA:n,SPECIAL_EVENT_SIGNUP_ENABLED:!0,DEV_APP_USER_LIMIT:150,STRIPE_PUBLISHABLE_KEY:s,DELEGATED_ACTIONS_TEE_PUBLIC_KEY:c})},98501:(e,r,t)=>{"use strict";t.d(r,{A:()=>n});var a=t(69955),o=t(65147);class i extends o.i{set(e,r){let t=this.getWalletStorageKey(e),a={share:r.share,deviceId:r.deviceId};this._set(t,a)}get(e){let r=this.getWalletStorageKey(e);return this._get(r)}del(e){let r=this.getWalletStorageKey(e);this._del(r)}getWalletStorageKey(e){let{appId:r,userId:t,address:o}=e;return"privy_wallet:".concat(r,":").concat(t,":").concat((0,a.qi)(o)?(0,a.py)(o):o)}constructor(e){super(e)}}let n=(()=>{try{if("undefined"!=typeof globalThis&&globalThis.localStorage){globalThis.localStorage.setItem("privy-storage-check","t");let e=globalThis.localStorage.getItem("privy-storage-check");if(globalThis.localStorage.removeItem("privy-storage-check"),"t"!==e)throw console.debug("Localstorage check failed"),Error("Unable to ping localStorage");return new i(globalThis.localStorage)}}catch(e){e instanceof DOMException&&"SecurityError"===e.name?console.debug("Security settings in your browser prevent access to local storage, used for persisting wallet state. Wallet information will be stored in-memory."):console.debug("Unknown issue loading local storage, used for persisting wallet state. Wallet information will be stored in-memory.")}return new i(new o._)})()},21435:(e,r,t)=>{"use strict";t.d(r,{A:()=>ey});var a=t(69955),o=t(96439),i=t(64291),n=t(46394),s=t(84192),c=t(18566),d=t(4894),l=t(26118);let u=["eth_sign","eth_populateTransactionRequest","eth_signTransaction","eth_sendTransaction","personal_sign","eth_signTypedData_v4","csw_signUserOperation","secp256k1_sign"];var y=t(94531),v=t(2560);async function w(e,r){return await e.wallet.sign({hash:r})}var p=t(43392),_=t(24895),f=t(77242),h=t(23360),m=t(44569),g=t(82927),k=t(19075),b=t(49857),P=t(33203),I=t(62808),T=t(33808),A=t(40683),S=t(54973),E=t(98158),K=t(23955),x=t(77535),F=t(97474),C=t(70323),U=t(1409),R=t(93381),N=t(31404),q=t(48008),O=t(62978),D=t(54968),M=t(87873),G=t(49288),L=t(42387),B=t(46658),V=t(6722),j=t(95427),z=t(24385);let W=(0,t(54676).x)({id:6900,name:"Animechain Testnet",nativeCurrency:{decimals:18,name:"ANIME",symbol:"ANIME"},rpcUrls:{default:{http:["https://rpc-animechain-testnet-i8yja6a1a0.t.conduit.xyz"],webSocket:["wss://rpc-animechain-testnet-i8yja6a1a0.t.conduit.xyz"]}},blockExplorers:{default:{name:"Explorer",url:"https://explorer-animechain-testnet-i8yja6a1a0.t.conduit.xyz"}}}),Y={[f.D.id]:f.D,[h.R.id]:h.R,[m.Y.id]:m.Y,[g.m.id]:g.m,[k.C.id]:k.C,[b.E.id]:{...b.E,rpcUrls:{default:{http:["https://thrumming-thrumming-pool.base-mainnet.quiknode.pro/afc8a0038cd744f30fd210e6f8c6b59ed5817bd7"]}}},[P.C.id]:P.C,[I.Z.id]:I.Z,[T.v.id]:T.v,[A._.id]:A._,[S.A.id]:S.A,[E.p.id]:E.p,[K.G.id]:K.G,[x.O.id]:x.O,[F.h.id]:F.h,[C.G.id]:{...C.G,rpcUrls:{default:{http:["https://quaint-morning-star.ethereum-sepolia.quiknode.pro/0063bd92e4f0adaa5b76cbd168121be661100ed9/"]}}},[U.y.id]:U.y,[l.r.id]:{...l.r,rpcUrls:{default:{http:["https://crimson-wider-silence.quiknode.pro/50060fe02eaca407606719d97f4f204f28da43ed"]}}},[R._.id]:R._,[N.Z.id]:N.Z,[q.F.id]:q.F,[O.R.id]:O.R,[D.t.id]:D.t,[M.i.id]:M.i,[G.n.id]:G.n,[L.E.id]:L.E,[B.n.id]:B.n,[V.L.id]:V.L,[j.q.id]:j.q,[z.a.id]:z.a,[W.id]:W},H={8453:"https://base-mainnet.blastapi.io",84531:"https://base-goerli.blastapi.io"},Q=e=>{let r=Y[e];if(!r)throw Error("Unsupported chainId ".concat(e));return r},Z=e=>{var r,t;let a;let o=Q(e);if(null===(r=o.rpcUrls.infura)||void 0===r?void 0:r.http[0]){if(!p.A.PRIVY_INFURA_ID)throw Error("Missing Infura ID for RPC URL");a=(0,_.j8)(o.rpcUrls.infura.http[0],p.A.PRIVY_INFURA_ID)}else if(H[e]){if(!p.A.PRIVY_BLAST_ID)throw Error("Missing Blast ID for RPC URL");a=(0,_.j8)(H[e],p.A.PRIVY_BLAST_ID)}else a=null===(t=o.rpcUrls.default)||void 0===t?void 0:t.http[0];if(!a)throw Error("No RPC url found for ".concat(e));return a};var J=t(1048).Buffer;let X={0:"legacy",1:"eip2930",2:"eip1559",3:"eip4844"},$={legacy:0,eip2930:1,eip1559:2,eip4844:3},ee=e=>void 0!==e?BigInt(e):void 0;function er(e){var r,t,a,i;let c;let{type:d=2,...u}="string"==typeof e?JSON.parse(e):e;u.accessList&&Array.isArray(u.accessList)?c=u.accessList.map(e=>Array.isArray(e)?{address:e[0],storageKeys:e[1]}:e):u.accessList&&(c=Object.entries(u.accessList).map(e=>({address:e[0],storageKeys:e[1]})));let y=Number(null!==(r=u.chainId)&&void 0!==r?r:l.r.id),v=(0,n.q)(u.data)?u.data:u.data?(0,s.nj)(Uint8Array.from(u.data)):void 0,w=u.nonce?Number(u.nonce):void 0;if(0===d)return{...u,type:X[d],chainId:y,data:v,value:ee(u.value),gasPrice:ee(u.gasPrice),gas:ee(null!==(t=u.gas)&&void 0!==t?t:u.gasLimit),nonce:w,accessList:void 0,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(1===d)return{...u,type:X[d],chainId:y,data:v,value:ee(u.value),gasPrice:ee(u.gasPrice),gas:ee(null!==(a=u.gas)&&void 0!==a?a:u.gasLimit),nonce:w,accessList:c,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(2===d)return{...u,type:X[d],chainId:y,data:v,value:ee(u.value),gas:ee(null!==(i=u.gas)&&void 0!==i?i:u.gasLimit),nonce:w,accessList:c,maxFeePerGas:ee(u.maxFeePerGas),maxPriorityFeePerGas:ee(u.maxPriorityFeePerGas),gasPrice:void 0,maxFeePerBlobGas:void 0};throw new o.Pi("invalid_request_arguments","Unsupported transaction type: ".concat(d))}function et(e){if("private-key"===e.entropyType)return J.from(e.entropy);let r=e.wallet.getHdKey().privateKey;if(!r)throw new o.Pi("wallet_not_on_device","Unable to read private key from HD account");return J.from(r)}async function ea(e,r,t){return eu(e.wallet.address,r),(0,i.personalSign)({privateKey:et(e),data:t})}async function eo(e,r,t,a){return eu(e.wallet.address,r),(0,i.signTypedData)({data:t,privateKey:et(e),version:a})}async function ei(e,r,t,a){let o=function(e){var r,t;let{userOperation:a,chainId:o,entrypointAddress:i}=e,n=(0,y.h)([{name:"sender",type:"address"},{name:"nonce",type:"uint256"},{name:"initCode",type:"bytes32"},{name:"callData",type:"bytes32"},{name:"callGasLimit",type:"uint256"},{name:"verificationGasLimit",type:"uint256"},{name:"preVerificationGas",type:"uint256"},{name:"maxFeePerGas",type:"uint256"},{name:"maxPriorityFeePerGas",type:"uint256"},{name:"paymasterAndData",type:"bytes32"}],[a.sender,a.nonce,(0,v.S)(null!==(r=a.initCode)&&void 0!==r?r:"0x"),(0,v.S)(a.callData),a.callGasLimit,a.verificationGasLimit,a.preVerificationGas,a.maxFeePerGas,a.maxPriorityFeePerGas,(0,v.S)(null!==(t=a.paymasterAndData)&&void 0!==t?t:"0x")]),s=(0,v.S)(n),c=(0,y.h)([{name:"userOpHash",type:"bytes32"},{name:"entryPoint",type:"address"},{name:"chainId",type:"uint256"}],[s,i,BigInt(o)]);return(0,v.S)(c)}({userOperation:r,chainId:a,entrypointAddress:t});return await w(e,o)}async function en(e,r){return await e.wallet.sign({hash:r})}async function es(e,r){let{method:t,params:a}=r;if(!u.includes(t))throw Error("Unsupported JSON RPC method: ".concat(t));switch(t){case"personal_sign":return{method:t,data:await ea(e,a[1],a[0])};case"eth_populateTransactionRequest":return{method:t,data:await ed(e,a[0])};case"eth_sign":return eu(e.wallet.address,a[0]),{method:t,data:await e.wallet.signMessage({message:a[1]})};case"eth_signTypedData_v4":{let r=function(e){if("string"!=typeof e)return e;try{let r=JSON.parse(e);return void 0!==r.domain.chainId&&(r.domain.chainId=Number(r.domain.chainId)),r}catch(e){throw Error("Failed to deserialize message with error: ".concat(e))}}(a[1]);return{method:t,data:await eo(e,a[0],r,i.SignTypedDataVersion.V4)}}case"eth_signTransaction":{let r=er(a[0]);return{method:t,data:await e.wallet.signTransaction(r)}}case"eth_sendTransaction":return{method:t,data:await ec(e,a[0])};case"csw_signUserOperation":{let[r,o,i]=a;return{method:t,data:await ei(e,r,o,i)}}case"secp256k1_sign":{let[r]=a;return{method:t,data:await en(e,r)}}}}async function ec(e,r){try{let{chainId:t=l.r.id,...a}=er(r),o=Q(t),i=Z(t),n=(0,c.F)({chain:o,account:e.wallet,transport:(0,d.L)(i)});return await n.sendTransaction(a)}catch(e){throw el(e)}}async function ed(e,r){try{let{chainId:t=l.r.id,...a}=er(r),o=Q(t),i=Z(t),n=(0,c.F)({account:e.wallet.address,chain:o,transport:(0,d.L)(i)}),{type:s,...u}=await n.prepareTransactionRequest(a);return{...u,type:$[s]}}catch(e){throw el(e)}}function el(e){let r=e.code,t=e.reason;return"INSUFFICIENT_FUNDS"===r?new o.Pi("insufficient_funds","Wallet has insufficient funds for this transaction"):t?new o.Pi("error",t):"string"==typeof e?Error(e):e}function eu(e,r){if(!(0,a.LH)(e,r))throw Error("Signer ".concat(e," can not sign on behalf of ").concat(r))}function ey(e,r){if(!(0,a.qi)(e.wallet.address))throw new o.Pi("invalid_request_arguments","Failed to service JSON RPC request: missing or invalid wallet address");return es(e,r)}},16894:(e,r,t)=>{"use strict";t.d(r,{A:()=>i});var a=t(96439),o=t(67114);function i(e,r){let{request:t,signingPublicKey:i,publicKey:n,hdWalletIndex:s}=r;if(void 0!==s&&0!==s&&void 0===i)throw new a.Pi("invalid_request_arguments","signingPublicKey must be passed when signing with a wallet with an HD index that is not 0.");return o.p({keypair:e,request:t,expectedPublicKey:null!=i?i:n})}},31586:(e,r,t)=>{"use strict";t.d(r,{h6:()=>_,kL:()=>p,io:()=>w,jt:()=>T.A,Zv:()=>A.A,uP:()=>P,JG:()=>m,_U:()=>K});var a=t(36073),o=t(82926),i=t.n(o),n=t(69955),s=t(8614),c=t(96439);let d={"recovery-encryption-key":"recovery_encryption_key","user-passcode":"user_passcode_derived_recovery_key",privy:"privy_generated_recovery_key","google-drive":"google_drive_recovery_secret",icloud:"icloud_recovery_secret","icloud-native":"icloud_recovery_secret"};var l=t(98501),u=t(51691),y=t(1048).Buffer;async function v(e){let{appId:r,appClientId:t,userId:a,walletAddress:o,accessToken:i,clientType:s,recoveryPassword:l,recoveryMethod:y,recoveryAccessToken:v,recoveryPin:w,recoveryKey:p,recoverySecretOverride:_,iCloudRecordNameOverride:f,createWalletEvent:h}=e,m=l||w;if(void 0!==m&&!(0,n.jt)(m))throw new c.Pi("invalid_request_arguments","Failed to create wallet: invalid recovery pin");if("icloud-native"===y&&(!_||!f))throw new c.Pi("invalid_request_arguments","Failed to create wallet: recoverySecret and iCloudRecordName must be overridden for icloud-native recovery");if("icloud-native"!==y&&(_||f))throw new c.Pi("invalid_request_arguments","Failed to create wallet: recoverySecret and iCloudRecordName can only be overridden for icloud-native recovery");if("recovery-encryption-key"===y&&!p)throw new c.Pi("invalid_request_arguments","Failed to create wallet: invalid recovery key");let g=y?d[y]:void 0;g||(g=void 0!==m?"user_passcode_derived_recovery_key":"privy_generated_recovery_key");let k=(0,u.Zw)({recoveryType:g,appId:r,appClientId:t,userId:a,entropyId:o,clientType:s,recoveryPassword:m,recoveryKey:p,recoveryAccessToken:v,accessToken:i,recoverySecretOverride:_,iCloudRecordNameOverride:f,createWalletEvent:h}),{encryptionKey:b,walletRecoveryOutput:P}=await (0,u.cq)(k);return{encryptionKey:b,walletRecoveryOutput:P,recoveryType:g}}async function w(e){let r,{appId:t,appClientId:o,userId:i,accessToken:c,clientType:d,recoveryPassword:y,recoveryMethod:w,recoveryAccessToken:p,recoveryPin:_,recoveryKey:f,recoverySecretOverride:h,iCloudRecordNameOverride:m,createWalletEvent:g,existingEntropy:k}=e,b=[new Uint8Array([]),new Uint8Array([])],P=[new Uint8Array([]),new Uint8Array([])];k?({deviceShares:b}=await (0,n.MR)(k),r=(0,n.Ay)({entropy:k,walletIndex:0})):{deviceShares:b,recoveryShares:P,wallet:r}=await (0,n.sr)();let[I,T]=b,A=await s.QQ({appId:t,appClientId:o,accessToken:c,address:r.address,chainType:"ethereum"}),S=(0,n.t5)(window.location.host,window.location.origin,r.address,A),E=await r.signMessage({message:S}),K=(0,n.hE)();if(k)await s.ry(t,o,c,{message:S,signature:E,device_auth_share:a.K3.encode(T),device_id:K});else{let[e,l]=P,{encryptionKey:k,walletRecoveryOutput:b,recoveryType:I}=await v({appId:t,appClientId:o,userId:i,accessToken:c,walletAddress:r.address,clientType:d,recoveryMethod:w,recoveryPassword:y,recoveryPin:_,recoveryKey:f,recoveryAccessToken:p,recoverySecretOverride:h,iCloudRecordNameOverride:m,createWalletEvent:g}),[A,x]=await Promise.all([(0,n.EN)(k),(0,n.vb)(e,k)]),F=await (0,u.qz)(b);await s.gc({appId:t,appClientId:o,accessToken:c,data:{chain_type:"ethereum",message:S,signature:E,device_id:K,device_auth_share:a.K3.encode(T),recovery_auth_share:a.K3.encode(l),encrypted_recovery_share:a.K3.encode(x.encryptedShare),encrypted_recovery_share_iv:a.K3.encode(x.encryptedShareIV),recovery_type:I,recovery_key_hash:a.K3.encode(A),imported:!1,...F}})}return l.A.set({appId:t,userId:i,address:r.address},{share:a.K3.encode(I),deviceId:K}),{wallet:r,walletIndex:0}}async function p(e){let r,t,{appId:o,appClientId:c,userId:d,accessToken:v,existingEntropy:w}=e,p=[new Uint8Array([]),new Uint8Array([])],_=[new Uint8Array([]),new Uint8Array([])];w?({deviceShares:p}=await (0,n.MR)(w),r=(0,n.kG)({entropy:w,index:0}),t=w):{deviceShares:p,recoveryShares:_,keypair:r,entropy:t}=await (0,n.IV)(256);let f=r.publicKey.toBase58(),[h,m]=p,g=await s.QQ({appId:o,appClientId:c,accessToken:v,address:f,chainType:"solana"}),k=(0,n.zT)(window.location.host,window.location.origin,f,g),b=i().sign.detached(y.from(k),r.secretKey),P=a.K3.encode(y.from(b)),I=(0,n.hE)();if(w)await s.IV(o,c,v,{message:k,signature:P,device_id:I,device_auth_share:a.K3.encode(m)});else{let{encryptionKey:e,walletRecoveryOutput:r}=await (0,u.cq)({recoveryType:"privy_generated_recovery_key"}),{recovery_key:t}=await (0,u.qz)(r),[i,d]=_,[l,y]=await Promise.all([(0,n.EN)(e),(0,n.vb)(i,e)]);await s.gc({appId:o,appClientId:c,accessToken:v,data:{chain_type:"solana",message:k,signature:P,device_id:I,device_auth_share:a.K3.encode(m),recovery_auth_share:a.K3.encode(d),encrypted_recovery_share:a.K3.encode(y.encryptedShare),encrypted_recovery_share_iv:a.K3.encode(y.encryptedShareIV),recovery_type:"privy_generated_recovery_key",recovery_key_hash:a.K3.encode(l),recovery_key:t,imported:!1}})}return l.A.set({appId:o,userId:d,address:f},{share:a.K3.encode(h),deviceId:I}),{entropyType:"hd-entropy",chainType:"solana",wallet:{keypair:r,address:f},walletIndex:0,entropy:t}}async function _(e){let{appId:r,appClientId:t,accessToken:a,hdWalletIndex:o,entropy:i}=e;if(o<=0)throw new c.Pi("invalid_request_arguments","Failed to create additional wallet: invalid wallet index");let d=(0,n.Ay)({entropy:i,walletIndex:o}),l=await s.QQ({appId:r,appClientId:t,accessToken:a,address:d.address,chainType:"ethereum"}),u=(0,n.t5)(window.location.host,window.location.origin,d.address,l),y=await d.signMessage({message:u});return await s.Zn({appId:r,appClientId:t,accessToken:a,data:{message:u,signature:y,hd_node_index:o,chain_type:"ethereum"}}),d}var f=t(60286),h=t(69899);async function m(e){let{cachedWalletData:r,appId:t,appClientId:a,clientAnalyticsId:o,userId:i,hdWalletIndex:s,chainType:d,entropyId:l,entropyIdVerifier:u,accessToken:y,mfaCode:v,mfaMethod:w,relyingParty:p}=e,{entropy:_,entropyType:m}=await (0,h.A)({cache:r,appId:t,appClientId:a,clientAnalyticsId:o,userId:i,entropyId:l,entropyIdVerifier:u,accessToken:y,mfaCode:v,mfaMethod:w,relyingParty:p});if(r&&_===r.entropy&&r.entropyId===l&&r.chainType===d&&r.walletIndex===s)return r;if("private-key"===m&&"ethereum"===d)return{entropy:_,entropyType:m,entropyId:l,entropyIdVerifier:u,chainType:"ethereum",walletIndex:void 0,wallet:(0,n.st)({entropy:_})};if("private-key"===m&&"solana"===d){let e=(0,n.Wi)({entropy:_});return{entropy:_,entropyType:m,entropyId:l,entropyIdVerifier:u,chainType:d,walletIndex:void 0,wallet:{keypair:e,address:e.publicKey.toBase58()}}}if("hd-entropy"===m&&"ethereum"===d)return{entropy:_,entropyType:m,entropyId:l,entropyIdVerifier:u,chainType:d,walletIndex:s,wallet:(0,n.Ay)({entropy:_,walletIndex:s})};if("hd-entropy"===m&&"solana"===d){let e=(0,n.kG)({entropy:_,index:s});return{entropy:_,entropyType:m,entropyId:l,entropyIdVerifier:u,chainType:d,walletIndex:s,wallet:{keypair:e,address:e.publicKey.toBase58()}}}if("hd-entropy"===m&&"bitcoin-segwit"===d)return{entropyType:m,entropy:_,entropyId:l,entropyIdVerifier:u,chainType:d,walletIndex:s,wallet:(0,f.E)({entropy:_,index:s,pathType:"segwit"})};if("hd-entropy"===m&&"bitcoin-taproot"===d)return{entropyType:m,entropy:_,entropyId:l,entropyIdVerifier:u,chainType:d,walletIndex:s,wallet:(0,f.E)({entropy:_,index:s,pathType:"taproot"})};throw new c.Pi("invalid_request_arguments","Failed to initialize ".concat(d," wallet at index ").concat(s))}var g=t(32395),k=t(93068),b=t(99090);async function P(e){let r,t,o,{appId:i,appClientId:d,clientAnalyticsId:u,userId:y,accessToken:v,clientType:w,entropyId:p,entropyIdVerifier:_,recoveryPassword:f,recoveryKey:h,mfaCode:m,mfaMethod:P,relyingParty:T,recoveryAccessToken:A,recoverySecretOverride:S}=e;if("ethereum-address-verifier"!==_||(0,n.qi)(p)){if("solana-address-verifier"===_&&!(0,n.Zf)(p))throw new c.Pi("invalid_request_arguments","Failed to recover wallet: missing or invalid wallet address")}else throw new c.Pi("invalid_request_arguments","Failed to recover wallet: missing or invalid wallet address");if(void 0!==f&&!(0,n.jt)(f))throw new c.Pi("invalid_request_arguments","Failed to recover wallet: invalid recovery pin");let E=await (0,b.X)({appId:i,appClientId:d,userId:y,accessToken:v,mfaMethod:P,mfaCode:m,relyingParty:T}),{recovery_type:K,recovery_key_derivation_salt:x,recovery_code:F,recovery_key:C,file_id:U,icloud_record_name:R}=await s.j({appId:i,appClientId:d,accessToken:v,entropyId:p,entropyIdVerifier:_});if("icloud_recovery_secret"!==K&&S)throw new c.Pi("invalid_request_arguments","Failed to recover wallet: recovery secret override is only supported for iCloud recovery");if("user_passcode_derived_recovery_key"===K){if(!f)throw new c.Pi("error","Failed to recover wallet: user passcode required and none found");if(!x)throw new c.Pi("error","Failed to recover wallet: cannot retrieve salt for user-supplied passcode derived wallet");r=await (0,n.Ud)(f,a.K3.decode(x))}else if("privy_passcode_derived_recovery_key"===K){if(!x)throw new c.Pi("error","Failed to recover wallet: cannot retrieve salt for Privy-supplied passcode derived wallet");if(!F)throw new c.Pi("error","Failed to recover wallet: cannot retrieve Privy-supplied passcode");r=await (0,n.Ud)(F,a.K3.decode(x))}else if("privy_generated_recovery_key"===K){if(!C)throw new c.Pi("error","Failed to recover wallet: cannot retrieve Privy-generated recovery key");r=await (0,n.kS)(a.K3.decode(C))}else if("google_drive_recovery_secret"===K){let e;if(!U)throw new c.Pi("error","Failed to recover wallet: cannot retrieve fileId for Google Drive recovery secret derived recovery key");if(!A)throw new c.Pi("error","Failed to recover wallet: missing recovery auth access token");try{e=await (0,g.lT)(A,{fileId:U})}catch(e){throw new c.Pi("error","Failed to recover wallet: failed to read recovery secret from Google Drive")}if(!e)throw new c.Pi("error","Failed to recover wallet: missing recovery secret from Google Drive");r=await (0,n.kS)(a.K3.decode(e))}else if("icloud_recovery_secret"===K){let e;if(S)e=S;else{if(!R)throw new c.Pi("error","Failed to recover wallet: cannot retrieve iCloud record name for iCloud recovery secret derived recovery key");if(!A)throw new c.Pi("error","Failed to recover wallet: missing recovery auth access token");try{let{cloudKitContainerIdentifier:r,cloudKitEnvironment:t,cloudKitApiToken:a}=await (0,k.hf)(i,d,v,w);e=await (0,k.WT)({ckWebAuthToken:A,recordName:R,entropyId:p,cloudKitContainerIdentifier:r,cloudKitEnvironment:t,cloudKitApiToken:a,createWalletEvent:(e,r)=>s.$1({appId:i,appClientId:d,accessToken:v,clientId:u,eventName:e,payload:{...r,entropyIdVerifier:_}})})}catch(e){if(e instanceof c.Pi)throw e;throw new c.Pi("unknown_icloud_recovery_error","Failed to recover wallet: unknown issue reading recovery secret from iCloud")}if(!e)throw new c.Pi("error","Failed to recover wallet: missing recovery secret from iCloud")}r=await (0,n.kS)(a.K3.decode(e))}else if("recovery_encryption_key"===K){if(!h)throw new c.Pi("error","Failed to recover wallet: missing recovery key");r=await (0,n.kS)(a.K3.decode(h))}if(!r)throw new c.Pi("error","Failed to recover wallet recovery key");let N=await (0,n.EN)(r),{recoveryAuthShare:q,encryptedRecoveryShare:O,encryptedRecoveryShareIV:D,imported:M}=await I({appId:i,appClientId:d,accessToken:v,entropyId:p,entropyIdVerifier:_,recoveryKeyHash:a.K3.encode(N),mfaToken:E}),G=await (0,n.nz)(a.K3.decode(O),a.K3.decode(D),r);if("ethereum-address-verifier"===_&&M){let{reconstructedWallet:e,reconstructedPrivateKey:r}=await (0,n.Pp)({shares:[G,a.K3.decode(q)],expectedAddress:p});t={entropyId:p,entropyIdVerifier:_,chainType:"ethereum",entropyType:"private-key",wallet:e,entropy:r,walletIndex:void 0},o=r}else if("ethereum-address-verifier"===_){let{entropy:e,wallet:r}=await (0,n.p$)({shares:[G,a.K3.decode(q)],primaryAddress:p,walletIndex:0});o=(t={entropyId:p,entropyIdVerifier:_,chainType:"ethereum",entropyType:"hd-entropy",wallet:r,entropy:e,walletIndex:0}).entropy}else if("solana-address-verifier"===_&&M){let{reconstructedKeypair:e,reconstructedPrivateKey:r}=await (0,n.IX)({shares:[G,a.K3.decode(q)],expectedAddress:p});t={chainType:"solana",entropyType:"private-key",entropyId:p,entropyIdVerifier:_,wallet:{keypair:e,address:e.publicKey.toBase58()},walletIndex:void 0,entropy:r},o=r}else if("solana-address-verifier"===_){let{reconstructedKeypair:e,reconstructedEntropy:r}=await (0,n.M4)({shares:[G,a.K3.decode(q)],expectedPublicKey:p,index:0});t={chainType:"solana",entropyType:"hd-entropy",entropyId:p,entropyIdVerifier:_,wallet:{keypair:e,address:e.publicKey.toBase58()},walletIndex:0,entropy:r},o=r}else throw new c.Pi("error","Failed to recover wallet: entropyIdVerifier ".concat(_," not supported"));let L=(0,n.hE)(),[B,V]=await (0,n.uY)(o),j=a.K3.encode(V);return await s.Dz({userId:y,appId:i,appClientId:d,accessToken:v,entropyId:p,entropyIdVerifier:_,deviceId:L,deviceAuthShare:j}),l.A.set({appId:i,userId:y,address:p},{share:a.K3.encode(B),deviceId:L}),t}async function I(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:i,recoveryKeyHash:n,mfaToken:d}=e;try{let[e,c]=await Promise.all([s.bz({appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:i,mfaToken:d}),s.jh({appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:i,recoveryKeyHash:n})]);return{recoveryAuthShare:e.share,encryptedRecoveryShare:c.encrypted_recovery_share,encryptedRecoveryShareIV:c.encrypted_recovery_share_iv,imported:c.imported}}catch(e){var l;if((null===(l=e.response)||void 0===l?void 0:l.status)===400)throw new c.Pi("invalid_recovery_pin","Failed to recover wallet: invalid recovery pin");if((0,c.$J)(e))throw new c.Pi("missing_or_invalid_mfa","MFA verification failed");throw new c.Pi("error","Failed to recover wallet: unknown error")}}var T=t(21435),A=t(16894);let S=e=>{throw Error("Expected never got ".concat(e))};var E=t(1048).Buffer;async function K(e){let{appId:r,appClientId:t,userId:o,accessToken:i,clientType:y,entropy:v,entropyId:w,entropyIdVerifier:p,recoveryOptions:_,createWalletEvent:f}=e,h=d[_.recoveryMethod];_.existingRecoveryMethod&&function(e){let{currentRecoveryMethod:r,upgradeToRecoveryMethod:t}=e;switch(r){case"privy_generated_recovery_key":case"user_passcode_derived_recovery_key":case"privy_passcode_derived_recovery_key":case"recovery_encryption_key":return;case"icloud_recovery_secret":case"google_drive_recovery_secret":if(r===t)throw Error("Cannot upgrade to the existing cloud platform");return;default:S(r)}}({currentRecoveryMethod:d[_.existingRecoveryMethod],upgradeToRecoveryMethod:h});let m=(0,u.Zw)({recoveryType:h,appId:r,appClientId:t,userId:o,entropyId:w,clientType:y,accessToken:i,createWalletEvent:f,recoveryPassword:"user-passcode"===_.recoveryMethod?_.recoveryPassword:void 0,recoveryAccessToken:"google-drive"===_.recoveryMethod||"icloud"===_.recoveryMethod?_.recoveryAccessToken:void 0,recoverySecretOverride:"icloud-native"===_.recoveryMethod?_.recoverySecretOverride:void 0,iCloudRecordNameOverride:"icloud-native"===_.recoveryMethod?_.iCloudRecordNameOverride:void 0}),g=l.A.get({appId:r,userId:o,address:w});if(!g)throw new c.Pi("wallet_not_on_device","Failed to initialize wallet: wallet with address '".concat(w,"' not loaded on this device"));let[k,b]=await Promise.all([(0,n.uY)(v),(0,n.uY)(v)]),[P,I]=k,[T,A]=b;await x({shares:[T,A],entropyId:w,entropyIdVerifier:p});let[E,{encryptionKey:K,walletRecoveryOutput:C}]=await Promise.all([s.QQ({appId:r,appClientId:t,accessToken:i,address:w,chainType:"ethereum-address-verifier"===p?"ethereum":"solana"}),(0,u.cq)(m)]),[U,R]=await Promise.all([(0,n.EN)(K),(0,n.vb)(T,K)]),[N,{message:q,signature:O}]=await Promise.all([(0,u.qz)(C),F({nonce:E,entropy:v,entropyId:w,entropyIdVerifier:p})]);return await s.p5({appId:r,appClientId:t,accessToken:i,data:{entropyIdVerifier:p,message:q,signature:O,device_id:g.deviceId,device_auth_share:a.K3.encode(I),recovery_type:h,recovery_auth_share:a.K3.encode(A),encrypted_recovery_share:a.K3.encode(R.encryptedShare),encrypted_recovery_share_iv:a.K3.encode(R.encryptedShareIV),recovery_key_hash:a.K3.encode(U),...N}}),l.A.set({appId:r,userId:o,address:w},{share:a.K3.encode(P),deviceId:g.deviceId}),{entropy:v,entropyId:w,entropyIdVerifier:p,entropyType:"hd-entropy"}}async function x(e){let{entropyIdVerifier:r,shares:t,entropyId:a}=e;"solana-address-verifier"===r?await (0,n.M4)({shares:t,expectedPublicKey:a,index:0}):await (0,n.p$)({shares:t,primaryAddress:a,walletIndex:0})}async function F(e){let{nonce:r,entropy:t,entropyId:o,entropyIdVerifier:s}=e;if("solana-address-verifier"===s){let e=(0,n.zT)(window.location.host,window.location.origin,o,r),s=(0,n.kG)({entropy:t,index:0}),c=i().sign.detached(E.from(e),s.secretKey);return{message:e,signature:a.K3.encode(c)}}{let e=(0,n.t5)(window.location.host,window.location.origin,o,r),a=(0,n.Ay)({entropy:t,walletIndex:0}),i=await a.signMessage({message:e});return{message:e,signature:i}}}},35438:(e,r,t)=>{"use strict";t.d(r,{A:()=>i});var a=t(65147);class o extends a.i{set(e,r){let t=this.getMfaTokenStorageKey(e);this._set(t,r)}get(e){let r=this.getMfaTokenStorageKey(e);return this._get(r)}del(e){let r=this.getMfaTokenStorageKey(e);this._del(r)}getMfaTokenStorageKey(e){let{appId:r,userId:t}=e;return"privy:mfa:".concat(r,":").concat(t)}constructor(e){super(e)}}let i=(()=>{try{if("undefined"!=typeof globalThis&&globalThis.localStorage)return new o(globalThis.localStorage)}catch(e){e instanceof DOMException&&"SecurityError"===e.name?console.debug("Security settings in your browser prevent access to local storage, used for persisting wallet state. Wallet information will be stored in-memory."):console.debug("Unknown issue loading local storage, used for persisting wallet state. Wallet information will be stored in-memory.")}return new o(new a._)})()},69899:(e,r,t)=>{"use strict";t.d(r,{A:()=>y});var a=t(96439),o=t(36073),i=t(58055),n=t(69955),s=t(8614),c=t(98501);let d=e=>{var r;return(null===(r=e.data)||void 0===r?void 0:r.code)==="device_revoked"};async function l(e){let r,t,{accessToken:a,appId:l,appClientId:u,clientAnalyticsId:y,userId:v,mfaToken:w,entropyId:p,entropyIdVerifier:_}=e,f={appId:l,userId:v,address:p},h=c.A.get(f);if(!h)return null;let{share:m,deviceId:g}=h;try{let e=await s.u({appId:l,appClientId:u,accessToken:a,clientAnalyticsId:y,mfaToken:w,deviceId:g,entropyId:p,entropyIdVerifier:_});r=e.share,t=e.imported}catch(e){if(d(e))return c.A.del(f),null;throw e}try{let e=await (0,i.k)([o.K3.decode(m),o.K3.decode(r)]);if("ethereum-address-verifier"===_&&t){let r=(0,n.st)({entropy:e});if(!(0,n.LH)(p,r.address))throw Error("Failed to reconstruct the expected wallet from Shamir shares")}else if("ethereum-address-verifier"===_){let r=(0,n.Ay)({entropy:e,walletIndex:0});if(!(0,n.LH)(p,r.address))throw Error("Failed to reconstruct the expected wallet from Shamir shares")}else if("solana-address-verifier"===_&&t){if((0,n.Wi)({entropy:e}).publicKey.toBase58()!==p)throw Error("Failed to reconstruct the expected public key from Shamir shares.")}else if("solana-address-verifier"===_&&(0,n.kG)({entropy:e,index:0}).publicKey.toBase58()!==p)throw Error("Failed to reconstruct the expected public key from Shamir shares.");return{entropy:e,entropyType:t?"private-key":"hd-entropy"}}catch(e){return c.A.del(f),null}}var u=t(99090);async function y(e){let{accessToken:r,appId:t,appClientId:o,clientAnalyticsId:i,userId:n,mfaCode:s,mfaMethod:c,relyingParty:d,entropyId:y,entropyIdVerifier:v,cache:w}=e,p=await (0,u.X)({appId:t,appClientId:o,userId:n,accessToken:r,mfaMethod:c,mfaCode:s,relyingParty:d});if(w&&!p&&w.entropyId===y)return{entropy:w.entropy,entropyType:w.entropyType};let _=await l({appId:t,clientAnalyticsId:i,appClientId:o,userId:n,accessToken:r,entropyId:y,entropyIdVerifier:v,mfaToken:p});if(!_)throw new a.Pi("wallet_not_on_device","Failed to initialize: '".concat(y,"' not loaded on this device"));return _}},99090:(e,r,t)=>{"use strict";t.d(r,{X:()=>n});var a=t(8614),o=t(96439),i=t(35438);async function n(e){var r;let{appId:t,appClientId:n,userId:s,accessToken:c,mfaMethod:d,mfaCode:l,relyingParty:u}=e,y=null===(r=i.A.get({appId:t,userId:s}))||void 0===r?void 0:r.token;if(l&&d)try{let e=await a.j2({appId:t,appClientId:n,accessToken:c,method:d,code:l,relyingParty:u});i.A.set({appId:t,userId:s},e),y=e.token}catch(e){throw new o.Pi("missing_or_invalid_mfa","MFA verification failed")}return null!=y?y:null}},51691:(e,r,t)=>{"use strict";t.d(r,{Zw:()=>c,cq:()=>d,qz:()=>l});var a=t(36073),o=t(69955),i=t(96439),n=t(32395),s=t(93068);function c(e){let{recoveryType:r,appId:t,appClientId:a,userId:n,entropyId:s,accessToken:c,clientType:d,recoveryPassword:l,recoveryKey:u,recoveryAccessToken:y,recoverySecretOverride:v,iCloudRecordNameOverride:w,createWalletEvent:p}=e;if("user_passcode_derived_recovery_key"===r){if(!l||!(0,o.jt)(l))throw new i.Pi("invalid_request_arguments","Failed to create wallet: missing or invalid recovery password");if(y)throw new i.Pi("invalid_request_arguments","Failed to create wallet: recovery access token should not be provided for user recovery secret protected wallets.");return{recoveryType:r,recoveryPassword:l}}if("privy_generated_recovery_key"===r){if(l)throw new i.Pi("invalid_request_arguments","Failed to create wallet: recovery password should not be provided for privy generated recovery key wallets.");if(y)throw new i.Pi("invalid_request_arguments","Failed to create wallet: recovery access token should not be provided for privy generated recovery key wallets.");return{recoveryType:r}}if("google_drive_recovery_secret"===r){if(!y)throw new i.Pi("invalid_request_arguments","Failed to create wallet: missing recovery access token");if(l)throw new i.Pi("invalid_request_arguments","Failed to create wallet: recovery password should not be provided for google drive recovery secret protected wallets.");return{recoveryType:r,recoveryAccessToken:y,appId:t,userId:n,entropyId:s}}if("icloud_recovery_secret"===r){if(!(y||v&&w))throw new i.Pi("invalid_request_arguments","Failed to create wallet: missing recovery access token or value overrides");if(l)throw new i.Pi("invalid_request_arguments","Failed to create wallet: recovery password should not be provided for iCloud recovery secret protected wallets.");if(!["web","expo-ios"].includes(d))throw new i.Pi("invalid_request_arguments","Failed to create wallet: client type ".concat(d," is not supported for iCloud recovery"));return{recoveryType:r,recoveryAccessToken:null!=y?y:null,appId:t,appClientId:a,userId:n,entropyId:s,customerAccessToken:c,clientType:d,recoverySecretOverride:null!=v?v:null,iCloudRecordNameOverride:null!=w?w:null,createWalletEvent:p}}if("recovery_encryption_key"===r){if(!u)throw new i.Pi("invalid_request_arguments","Failed to create wallet: missing or invalid recovery key");return{recoveryType:r,recoveryKey:u}}throw new i.Pi("invalid_request_arguments","Failed to create wallet: unknown recovery type: ".concat(r))}async function d(e){let{recoveryType:r}=e;if("user_passcode_derived_recovery_key"===r){let{recoveryPassword:t}=e,a=(0,o.s5)();return{encryptionKey:await (0,o.Ud)(t,a),walletRecoveryOutput:{recoveryType:r,recoveryKeyDerivationSalt:a}}}if("privy_generated_recovery_key"===r){let e=await (0,o.CI)();return{encryptionKey:e,walletRecoveryOutput:{recoveryType:r,encryptionKey:e}}}if("google_drive_recovery_secret"===r){let t;let{recoveryAccessToken:s}=e,c=await (0,o.CI)(),d=a.K3.encode(await (0,o.WQ)(c)),l=await (0,n.w5)({appId:e.appId,userId:e.userId,entropyId:e.entropyId});try{t=await (0,n.Vz)(s,{recoverySecret:d,filename:l})}catch(r){let e=r instanceof Error?r.message:"Provider error";throw new i.Pi("error","Failed to write recovery secret to Google Drive: ".concat(e))}return{encryptionKey:c,walletRecoveryOutput:{recoveryType:r,filename:l,fileId:t}}}if("icloud_recovery_secret"===r){let t;let{recoveryAccessToken:n,entropyId:c,appId:d,appClientId:l,userId:u,customerAccessToken:y,clientType:v,recoverySecretOverride:w,iCloudRecordNameOverride:p}=e;if(w&&!p||!w&&p)throw new i.Pi("invalid_request_arguments","Failed to create wallet: both recovery secret and iCloud record name must be provided if one is provided.");if(w&&p)return{encryptionKey:await (0,o.kS)(a.K3.decode(w)),walletRecoveryOutput:{recoveryType:r,recordName:p}};if(!n)throw new i.Pi("invalid_request_arguments","Failed to create wallet: missing recovery access token for iCloud recovery");let _=await (0,o.CI)(),f=a.K3.encode(await (0,o.WQ)(_));try{let{cloudKitContainerIdentifier:e,cloudKitEnvironment:r,cloudKitApiToken:a}=await (0,s.hf)(d,l,y,v);t=await (0,s.yt)({ckWebAuthToken:n,recoverySecretToStore:f,entropyId:c,appId:d,userId:u,cloudKitContainerIdentifier:e,cloudKitEnvironment:r,cloudKitApiToken:a})}catch(t){if((0,i.dS)(t))throw e.createWalletEvent(t.eventInfo.eventName,t.eventInfo.payload),t.convert();let r=t instanceof Error?t.message:"Provider error";throw new i.Pi("error","Failed to write recovery secret to iCloud: ".concat(r))}return{encryptionKey:_,walletRecoveryOutput:{recoveryType:r,recordName:t}}}if("recovery_encryption_key"===r){let{recoveryKey:t}=e;try{let e=await (0,o.kS)(a.K3.decode(t));return{encryptionKey:e,walletRecoveryOutput:{recoveryType:r,encryptionKey:e}}}catch(r){let e=r instanceof Error?r.message:"invalid key";throw new i.Pi("error","Unable to decode and import recovery key: ".concat(e))}}else throw Error("Unknown recovery type.")}async function l(e){let{recoveryType:r}=e;if("user_passcode_derived_recovery_key"===r){let{recoveryKeyDerivationSalt:r}=e;return{recovery_key_derivation_salt:a.K3.encode(r)}}if("privy_generated_recovery_key"===r){let{encryptionKey:r}=e;return{recovery_key:a.K3.encode(await (0,o.WQ)(r))}}if("google_drive_recovery_secret"===r){let{filename:r,fileId:t}=e;return{filename:r,file_id:t}}if("icloud_recovery_secret"===r){let{recordName:r}=e;return{icloud_record_name:r}}if("recovery_encryption_key"===r)return{};throw Error("Unknown recovery type: ".concat(r))}},63814:(e,r,t)=>{"use strict";t.d(r,{d:()=>n});var a=t(55945);let o="ES256",i={att:"pat"};async function n(e,r,t){if(!e)return console.error("No access token provided."),null;try{var a;let o=await s(e,t,r),i=(a=o.payload.sub,"string"==typeof a&&/^did:privy:.+/.test(a)?a.replace(/^did:privy:/,""):null);if(!i)return console.error("Unable to decode user ID. Audience claim:",o.payload.aud),null;if(!o.payload.aud)return console.error("Access token does not contain an audience claim."),null;return console.debug("Successfully verified access token."),{userId:i,appId:t}}catch(e){return console.error(e),null}}async function s(e,r,t){let n={typ:"JWT",algorithms:[o],issuer:"privy.io"},s=a.iU(e).att===i.att;s||(n.audience=r);let c=await Promise.allSettled(t.map(async t=>{let i=await a.jU(t,o),c=await a.Vv(e,i,n);if(s&&c.payload.aid!==r)throw Error("Access token does not have correct appId");return c})),d=c.find(e=>"fulfilled"===e.status);if(!d)throw c[0].reason;return d.value}},8614:(e,r,t)=>{"use strict";t.d(r,{$1:()=>T,AI:()=>M,Dz:()=>I,IV:()=>u,IW:()=>w,NB:()=>K,O:()=>A,QQ:()=>d,St:()=>S,Zn:()=>v,_o:()=>x,aV:()=>O,bz:()=>m,gc:()=>l,hH:()=>C,j:()=>g,j2:()=>q,jE:()=>F,jh:()=>k,p5:()=>p,q$:()=>E,ry:()=>y,u:()=>f,v$:()=>D});var a=t(2963),o=t(48016),i=t(35438);let n=e=>{var r;let t=new a.F(null===(r=e.response._data)||void 0===r?void 0:r.error);for(let r of["request","options","response"])Object.defineProperty(t,r,{get:()=>e[r]});for(let[r,a]of[["data","_data"],["status","status"],["statusCode","status"],["statusText","statusText"],["statusMessage","statusText"]])Object.defineProperty(t,r,{get:()=>e.response&&e.response[a]});throw t},s=async(e,r,t)=>await (0,o.OT)(e,{method:"POST",body:r,headers:t,timeout:9e3,credentials:"include",onResponseError:n}),c=async(e,r,t)=>await (0,o.OT)(e,{method:"PATCH",body:r,headers:t,timeout:9e3,credentials:"include",onResponseError:n});async function d(e){let{appId:r,appClientId:t,accessToken:a,address:o,chainType:i}=e;return(await s("/api/v1/embedded_wallets/init",{address:o,chain_type:i},G({appId:r,appClientId:t,accessToken:a}))).nonce}async function l(e){let{appId:r,appClientId:t,accessToken:a,data:o}=e;return await s("/api/v1/embedded_wallets",o,G({appId:r,appClientId:t,accessToken:a}))}async function u(e,r,t,a){return await s("/api/v1/embedded_wallets/add_solana",a,G({appId:e,appClientId:r,accessToken:t}))}async function y(e,r,t,a){return await s("/api/v1/embedded_wallets/add_ethereum",a,G({appId:e,appClientId:r,accessToken:t}))}async function v(e){let{appId:r,appClientId:t,accessToken:a,data:o}=e;return await s("/api/v1/embedded_wallets/add_wallet",o,G({appId:r,appClientId:t,accessToken:a}))}async function w(e){let{appId:r,appClientId:t,accessToken:a,data:o}=e;return await s("/api/v1/wallets/delegate",o,G({appId:r,appClientId:t,accessToken:a}))}async function p(e){let{appId:r,appClientId:t,accessToken:a,data:{entropyIdVerifier:o,...i}}=e;return await c("/api/v1/embedded_wallets",{...i,chain_type:B(o)},G({appId:r,appClientId:t,accessToken:a}))}let _=async e=>{let{appId:r,appClientId:t,clientAnalyticsId:o,accessToken:i,fn:n}=e;try{return await n()}catch(e){if(!(e instanceof a.F)||e.response)throw e;return T({appId:r,appClientId:t,clientId:o,accessToken:i,eventName:"retry_fetch_share_no_response",payload:{error:e.message}}),await n()}};async function f(e){let{appId:r,appClientId:t,clientAnalyticsId:a,accessToken:o,entropyId:i,entropyIdVerifier:n,deviceId:s,mfaToken:c}=e;return await _({appId:r,appClientId:t,accessToken:o,clientAnalyticsId:a,fn:()=>h({appId:r,appClientId:t,accessToken:o,entropyId:i,entropyIdVerifier:n,deviceId:s,mfaToken:c})})}async function h(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:i,deviceId:n,mfaToken:c}=e;return await s("/api/v1/embedded_wallets/".concat(o,"/share"),{device_id:n,chain_type:B(i)},G({appId:r,appClientId:t,accessToken:a,mfaToken:c}))}async function m(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:i,mfaToken:n}=e;return await s("/api/v1/embedded_wallets/".concat(o,"/recovery/auth_share"),{chain_type:B(i)},G({appId:r,appClientId:t,accessToken:a,mfaToken:n}))}async function g(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:i}=e;return await s("/api/v1/embedded_wallets/".concat(o,"/recovery/key_material"),{chain_type:B(i)},G({appId:r,appClientId:t,accessToken:a}))}async function k(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:i,recoveryKeyHash:n}=e;return await s("/api/v1/embedded_wallets/".concat(o,"/recovery/shares"),{recovery_key_hash:n,chain_type:B(i)},G({appId:r,appClientId:t,accessToken:a}))}async function b(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:i,deviceAuthShare:n,deviceId:c}=e;return await s("/api/v1/embedded_wallets/".concat(o,"/recovery/device"),{device_id:c,device_auth_share:n,chain_type:B(i)},G({appId:r,appClientId:t,accessToken:a}))}let P=e=>e&&e instanceof Error&&(e.message.includes("abort")||e.message.includes("timeout"));async function I(e){let{userId:r,appId:t,appClientId:a,accessToken:o,entropyId:n,entropyIdVerifier:s,deviceAuthShare:c,deviceId:d}=e;try{return await b({appId:t,appClientId:a,accessToken:o,entropyId:n,entropyIdVerifier:s,deviceAuthShare:c,deviceId:d})}catch(e){if(P(e)){var l,u;let{share:e}=await h({mfaToken:null!==(u=null===(l=i.A.get({appId:t,userId:r}))||void 0===l?void 0:l.token)&&void 0!==u?u:null,appId:t,appClientId:a,accessToken:o,entropyId:n,entropyIdVerifier:s,deviceId:d}).catch(()=>({share:null}));if(e)return{success:!0};return await b({appId:t,appClientId:a,accessToken:o,entropyId:n,entropyIdVerifier:s,deviceAuthShare:c,deviceId:d})}throw e}}function T(e){let{appId:r,appClientId:t,accessToken:a,clientId:o,eventName:i,payload:n,timestamp:c}=e;s("/api/v1/analytics_events",{event_name:i,client_id:o,payload:{...n||{},clientTimestamp:c?c.toISOString():new Date().toISOString()}},G({appId:r,appClientId:t,accessToken:a})).catch(()=>void 0)}async function A(e){let{appId:r,appClientId:t,accessToken:a,mfaToken:o}=e;return await s("/api/v1/mfa/totp/init",{action:"enroll"},G({appId:r,appClientId:t,accessToken:a,mfaToken:o}))}async function S(e){let{appId:r,appClientId:t,accessToken:a,mfaToken:o,phoneNumber:i}=e;return await s("/api/v1/mfa/passwordless_sms/init",{phoneNumber:i,action:"enroll"},G({appId:r,appClientId:t,accessToken:a,mfaToken:o}))}async function E(e){let{appId:r,appClientId:t,accessToken:a,code:o}=e;return await s("/api/v1/mfa/totp/enroll",{code:o},G({appId:r,appClientId:t,accessToken:a}))}async function K(e){let{appId:r,appClientId:t,accessToken:a,credentialIds:o,mfaToken:i,removeForLogin:n}=e;return await s("/api/v1/mfa/passkeys/enrollment",{credential_ids:o,remove_for_login:n},G({appId:r,appClientId:t,accessToken:a,mfaToken:i}))}async function x(e){let{appId:r,appClientId:t,accessToken:a,code:o,phoneNumber:i}=e;return await s("/api/v1/mfa/passwordless_sms/enroll",{phoneNumber:i,code:o},G({appId:r,appClientId:t,accessToken:a}))}async function F(e){let{appId:r,appClientId:t,accessToken:a,mfaToken:o}=e;return await s("/api/v1/mfa/passwordless_sms/unenroll",{},G({appId:r,appClientId:t,accessToken:a,mfaToken:o}))}async function C(e){let{appId:r,appClientId:t,accessToken:a,mfaToken:o}=e;return await s("/api/v1/mfa/totp/unenroll",{},G({appId:r,appClientId:t,accessToken:a,mfaToken:o}))}async function U(e){let{appId:r,appClientId:t,accessToken:a,code:o}=e;return await s("/api/v1/mfa/passwordless_sms/verify",{code:o},G({appId:r,appClientId:t,accessToken:a}))}async function R(e){let{appId:r,appClientId:t,accessToken:a,code:o}=e;return await s("/api/v1/mfa/totp/verify",{code:o},G({appId:r,appClientId:t,accessToken:a}))}async function N(e){let{appId:r,appClientId:t,accessToken:a,authenticatorResponse:o,relyingParty:i}=e;return await s("/api/v1/mfa/passkeys/verify",{authenticator_response:o,relying_party:i},G({appId:r,appClientId:t,accessToken:a}))}async function q(e){let{appId:r,appClientId:t,accessToken:a,code:o,method:i,relyingParty:n}=e;switch(i){case"sms":return await U({appId:r,appClientId:t,accessToken:a,code:o});case"totp":return await R({appId:r,appClientId:t,accessToken:a,code:o});case"passkey":return await N({appId:r,appClientId:t,accessToken:a,relyingParty:n,authenticatorResponse:o});default:throw Error("Unknown mfa method: ".concat(i))}}async function O(e){let{appId:r,appClientId:t,signerPublicKey:a,auth:o}=e;return await s("/api/v1/farcaster/signer/init",{ed25519_public_key:a},G({appId:r,appClientId:t,accessToken:o.accessToken,mfaToken:o.mfaToken}))}async function D(e){let{appId:r,appClientId:t,accessToken:a,mfaToken:o,credentialId:i,removeAsMfa:n}=e;return await s("/api/v1/passkeys/unlink",{credential_id:i,remove_as_mfa:n},G({appId:r,appClientId:t,accessToken:a,mfaToken:o}))}async function M(e){let{appId:r,appClientId:t,accessToken:a,data:o}=e;return await s("/api/v1/recovery/configuration_icloud",{client_type:o.client_type},G({appId:r,appClientId:t,accessToken:a}))}function G(e){let{appId:r,appClientId:t,accessToken:a,mfaToken:o}=e,i=new Headers;return i.set("privy-app-id",r),i.set("authorization","Bearer ".concat(a)),t&&i.set("privy-client-id",t),o&&i.set("privy-mfa-token",o),i}let L={"ethereum-address-verifier":"ethereum","solana-address-verifier":"solana"},B=e=>L[e]},96439:(e,r,t)=>{"use strict";t.d(r,{$J:()=>d,Pi:()=>i,RO:()=>n,dS:()=>c,xR:()=>s,z6:()=>o});let a=["error","invalid_request_arguments","wallet_not_on_device","hd_wallet_required","invalid_recovery_pin","insufficient_funds","missing_or_invalid_mfa","twilio_verification_failed","no_icloud_record_found","multiple_icloud_records_found","unknown_icloud_recovery_error","unknown_icloud_storage_error"],o="error";class i extends Error{constructor(e,r){super(r),this.type=e}}class n extends i{convert(){return new i(this.type,this.message)}constructor(e,r,t){super(e,r),this.type=e,this.eventInfo=t}}function s(e){let r=e.type;return"string"==typeof r&&a.includes(r)}function c(e){return s(e)&&!!e.convert}function d(e){var r;let t=null===(r=e.data)||void 0===r?void 0:r.code;return"missing_or_invalid_mfa"===t||"expired_or_invalid_mfa_token"===t}},32395:(e,r,t)=>{"use strict";t.d(r,{Vz:()=>s,lT:()=>c,w5:()=>n});var a=t(36073),o=t(94335),i=t(69955);async function n(e){let{appId:r,userId:t,entropyId:o}=e,n=await (0,i.YZ)(o),s=a.K3.encode(n);return"privy-wallet-".concat(r,"-").concat(t,"-").concat(s,".txt")}async function s(e,r){let{recoverySecret:t,filename:a}=r,i="recovery-secret-boundary",n="\r\n--".concat(i,"\r\n"),s=n+"Content-Type: application/json; charset=UTF-8\r\n\r\n"+JSON.stringify({name:a,mimeType:"text/plain",parents:["appDataFolder"]})+n+"Content-Type: text/plain\r\n\r\n"+t+"\r\n--".concat(i,"--");return(await o.A.post("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",s,{headers:{"Content-Type":'multipart/related; boundary="'.concat(i,'"'),Authorization:"Bearer ".concat(e)}})).data.id}async function c(e,r){let{fileId:t}=r;return(await o.A.get("https://www.googleapis.com/drive/v3/files/".concat(t),{headers:{Authorization:"Bearer ".concat(e)},params:{alt:"media"},responseType:"text"})).data}},93068:(e,r,t)=>{"use strict";t.d(r,{WT:()=>d,hf:()=>s,yt:()=>c});var a=t(48016),o=t(8614),i=t(96439);let n="https://api.apple-cloudkit.com/database/1";async function s(e,r,t,a){let i=await (0,o.AI)({appId:e,appClientId:r,accessToken:t,data:{client_type:a}});return{cloudKitContainerIdentifier:i.container_identifier,cloudKitEnvironment:i.environment,cloudKitApiToken:i.api_token}}async function c(e){var r,t,o;let{ckWebAuthToken:s,recoverySecretToStore:c,entropyId:d,appId:l,userId:u,cloudKitContainerIdentifier:y,cloudKitEnvironment:v,cloudKitApiToken:w}=e,p=encodeURIComponent(s),_="".concat(n,"/").concat(y,"/").concat(v,"/private/records/modify?ckAPIToken=").concat(w,"&ckWebAuthToken=").concat(p),f=await a.OT.raw(_,{method:"POST",body:{operations:[{operationType:"create",record:{recordType:"PrivyWallets",fields:{recovery_secret:{value:c},wallet_address:{value:d},app_id:{value:l},user_id:{value:u}}}}]},headers:{"Content-Type":"application/json"},ignoreResponseError:!0});if(!(null==f?void 0:null===(r=f._data)||void 0===r?void 0:r.records)||(null==f?void 0:null===(t=f._data)||void 0===t?void 0:t.records.length)===0||!(null===(o=f._data.records)||void 0===o?void 0:o[0]))throw new i.RO("no_icloud_record_found","Failed to store wallet: unknown issue storing recovery secret",{eventName:"icloud_write_error",payload:{detail:"no_icloud_record_found"}});if(f._data.records.length>1)throw new i.RO("multiple_icloud_records_found","Failed to store wallet: multiple iCloud records found for the user",{eventName:"icloud_write_error",payload:{detail:"multiple_icloud_records_found"}});let h=f._data.records[0];if("serverErrorCode"in h)throw console.warn("Unable to store with iCloud: ".concat(h.reason)),new i.RO("unknown_icloud_storage_error","Failed to store wallet: iCloud errored with code ".concat(h.serverErrorCode),{eventName:"icloud_write_error",payload:{detail:"icloud_server_issue",icloud_error_code:h.serverErrorCode,icloud_status:f.status,icloud_error_uuid:h.uuid}});if(f.status>=400)throw new i.RO("unknown_icloud_storage_error","Failed to store wallet: issue storing recovery secret",{eventName:"icloud_write_error",payload:{detail:"unknown_icloud_server_issue",icloud_status:f.status}});if(c!==h.fields.recovery_secret.value)throw new i.RO("unknown_icloud_storage_error","Failed to store wallet: iCloud stored wallet address does not match expected address.",{eventName:"icloud_write_error",payload:{detail:"wallet_address_mismatch"}});return h.recordName}async function d(e){var r,t,o;let{ckWebAuthToken:s,recordName:c,entropyId:d,cloudKitContainerIdentifier:l,cloudKitEnvironment:u,cloudKitApiToken:y,createWalletEvent:v}=e,w=encodeURIComponent(s),p="".concat(n,"/").concat(l,"/").concat(u,"/private/records/lookup?ckAPIToken=").concat(y,"&ckWebAuthToken=").concat(w),_=await a.OT.raw(p,{method:"POST",body:{records:{recordName:c}},headers:{"Content-Type":"application/json"},ignoreResponseError:!0});if(!(null==_?void 0:null===(r=_._data)||void 0===r?void 0:r.records)||(null==_?void 0:null===(t=_._data)||void 0===t?void 0:t.records.length)===0||!(null===(o=_._data.records)||void 0===o?void 0:o[0]))throw v("icloud_recovery_error",{detail:"no_icloud_record_found"}),new i.Pi("no_icloud_record_found","Failed to recover wallet: expected an iCloud recovery record, user possibly selected the wrong iCloud account");if(_._data.records.length>1)throw v("icloud_recovery_error",{detail:"multiple_icloud_records_found"}),new i.Pi("multiple_icloud_records_found","Failed to recover wallet: multiple iCloud records found for the user");let f=_._data.records[0];if("serverErrorCode"in f)throw v("icloud_recovery_error",{detail:"icloud_server_issue",icloud_error_code:f.serverErrorCode,icloud_status:_.status,icloud_error_uuid:f.uuid}),console.warn("Unable to recover with iCloud: ".concat(f.reason)),new i.Pi("unknown_icloud_recovery_error","Failed to recover wallet: iCloud errored with code ".concat(f.serverErrorCode));if(_.status>=400)throw v("icloud_recovery_error",{detail:"unknown_icloud_server_issue",icloud_status:_.status}),new i.Pi("unknown_icloud_recovery_error","Failed to recover wallet: issue fetching recovery secret");if(d!==f.fields.wallet_address.value)throw v("icloud_recovery_error",{detail:"wallet_address_mismatch"}),new i.Pi("unknown_icloud_recovery_error","Failed to recover wallet: iCloud stored wallet address does not match expected address.");return f.fields.recovery_secret.value}},67114:(e,r,t)=>{"use strict";t.d(r,{p:()=>s,x:()=>n});var a=t(82926),o=t.n(a),i=t(1048).Buffer;async function n(e,r,t){!function(e,r){if(e.toString()!==r)throw Error("Signer ".concat(e.toBase58()," cannot sign on behalf of ").concat(r))}(e.publicKey,r);let a=i.from(t,"base64");try{let r=o().sign.detached(a,e.secretKey);return i.from(r).toString("base64")}catch(e){throw console.error(e),e}}async function s(e){let{keypair:r,request:t,expectedPublicKey:a}=e,{method:o,params:i}=t;if("signMessage"===o)return{method:o,data:{signature:await n(r,a,i.message)}};throw Error("Unsupported method: ".concat(o))}},65147:(e,r,t)=>{"use strict";t.d(r,{_:()=>a,i:()=>o});class a{get length(){return Object.keys(this.data).length}getItem(e){let r=this.data[e];return void 0!==r?r:null}setItem(e,r){this.data[e]=String(r)}removeItem(e){delete this.data[e]}clear(){this.data={}}constructor(){this.data={}}}class o{_set(e,r){this.storage.setItem(e,JSON.stringify(r))}_get(e){let r=this.storage.getItem(e);if("string"!=typeof r)return null;try{return JSON.parse(r)}catch(r){return this.storage.removeItem(e),null}}_del(e){this.storage.removeItem(e)}constructor(e){this.storage=e}}},60286:(e,r,t)=>{"use strict";t.d(r,{E:()=>s});var a=t(95986),o=t(95210),i=t(89414),n=t(91574);function s(e){let{entropy:r,index:t,pathType:s}=e,d=a.c.fromMasterSeed((0,o.kw)((0,o.VF)(r,i.p))).derive(c(t,s));if(!d.publicKey||!d.privateKey)throw Error("Error deriving HD node for entropy");let l="taproot"===s?(0,n.bv)("tr",d.privateKey):(0,n.bv)("wpkh",d.privateKey);if(!l)throw Error("Error deriving address from private key");return{_node:d,address:l,privateKey:d.privateKey,publicKey:d.publicKey}}let c=(e,r)=>"taproot"===r?"m/86'/0'/0'/0/".concat(e):"m/84'/0'/0'/0/".concat(e)},69955:(e,r,t)=>{"use strict";t.d(r,{Ay:()=>K,Bt:()=>g,CD:()=>W,CI:()=>V,EN:()=>Z,IV:()=>P,IX:()=>R,LH:()=>S,M4:()=>q,MC:()=>Y,MR:()=>m,Pp:()=>U,UI:()=>k,Ud:()=>B,WQ:()=>j,Wi:()=>C,YZ:()=>J,Zf:()=>T,eB:()=>x,fj:()=>H,hE:()=>L,jt:()=>h,kG:()=>N,kS:()=>z,nz:()=>ee,p$:()=>E,py:()=>A,qi:()=>I,s5:()=>G,sr:()=>b,st:()=>F,t5:()=>D,uY:()=>O,vb:()=>$,zT:()=>M});var a=t(36073),o=t(95210),i=t(89414),n=t(3834),s=t(8448),c=t(58055),d=t(46394),l=t(29873),u=t(64569),y=t(84192),v=t(80815),w=t(66505),p=t(67114),_=t(1048).Buffer;function f(e){return crypto.getRandomValues(new Uint8Array(e))}function h(e){return"string"==typeof e&&/^[a-zA-Z0-9!@#$%^&*()\-_+.]{6,}$/.test(e)}async function m(e){return{deviceShares:await O(e),recoveryShares:await O(e)}}async function g(e){let r=new Uint8Array(_.from(e,"hex").buffer),{deviceShares:t,recoveryShares:a}=await m(r),o=(0,v.R)((0,d.q)(e)?e:"0x".concat(e));return{chainType:"ethereum",deviceShares:t,recoveryShares:a,wallet:o,entropy:r,signMessage:o.signMessage}}async function k(e){let r=a.tw.decode(e),{deviceShares:t,recoveryShares:o}=await m(r),i=n.AX.fromSecretKey(r),s=i.publicKey.toBase58();return{chainType:"solana",deviceShares:t,recoveryShares:o,wallet:i,address:s,signMessage:e=>{let{message:r}=e;return(0,p.x)(i,s,_.from(r).toString("base64"))},entropy:r}}async function b(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:128;if(![128,160,192,224,256].includes(e))throw Error("invalid entropy size");let r=f(e/8),{deviceShares:t,recoveryShares:a}=await m(r),o=K({entropy:r,walletIndex:0});return{entropy:r,deviceShares:t,recoveryShares:a,wallet:o}}async function P(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:256;if(![256].includes(e))throw Error("invalid entropy size");let r=f(e/8),{deviceShares:t,recoveryShares:a}=await m(r);return{deviceShares:t,recoveryShares:a,keypair:N({entropy:r,index:0}),entropy:r}}function I(e){return(0,l.P)(e)}function T(e){try{let r=new n.J3(e);return n.J3.isOnCurve(r)}catch(e){return!1}}function A(e){return(0,u.b)(e)}function S(e,r){return A(e)===A(r)}async function E(e){let{shares:r,primaryAddress:t,walletIndex:a}=e,o=await (0,c.k)(r),i=K({entropy:o,walletIndex:a});if(!S(0===a?i.address:K({entropy:o,walletIndex:0}).address,t))throw Error("Failed to reconstruct the expected wallet from Shamir shares");return{chainType:"ethereum",entropyType:"hd-entropy",wallet:i,entropy:o,walletIndex:a}}function K(e){let{entropy:r,walletIndex:t}=e;return x({entropy:r,opts:{addressIndex:t}})}function x(e){let{entropy:r,opts:t}=e;return(0,w.f)((0,o.VF)(r,i.p),t)}function F(e){let{entropy:r}=e;return(0,v.R)((0,y.nj)(r))}function C(e){let{entropy:r}=e;return n.AX.fromSecretKey(r)}async function U(e){let{shares:r,expectedAddress:t}=e,a=await (0,c.k)(r),o=F({entropy:a});if(o.address!==t)throw Error("Failed to reconstruct the expected address from Shamir shares.");return{reconstructedWallet:o,reconstructedPrivateKey:a}}async function R(e){let{shares:r,expectedAddress:t}=e,a=await (0,c.k)(r),o=n.AX.fromSecretKey(a);if(o.publicKey.toBase58()!==t)throw Error("Failed to reconstruct the expected address from Shamir shares.");return{reconstructedKeypair:o,reconstructedPrivateKey:a}}function N(e){let{entropy:r,index:t}=e,a=s.cf.fromMasterSeed(_.from(r).toString("hex"));return n.AX.fromSeed(a.derive("m/44'/501'/".concat(t,"'/0'")).privateKey)}async function q(e){let{shares:r,expectedPublicKey:t,index:a}=e,o=await (0,c.k)(r),i=N({entropy:o,index:a});if((0===a?i:N({entropy:o,index:0})).publicKey.toBase58()!==t)throw Error("Failed to reconstruct the expected public key from Shamir shares.");return{reconstructedKeypair:i,reconstructedEntropy:o}}function O(e){return(0,c.l)(e,2,2)}function D(e,r,t,a){return"".concat(e," wants you to sign in with your Ethereum account:\n").concat(t,"\n\nYou are proving you own ").concat(t,".\n\nURI: ").concat(r,"\nVersion: 1\nChain ID: 1\nNonce: ").concat(a,"\nIssued At: ").concat(new Date().toISOString(),"\nResources:\n- https://privy.io")}function M(e,r,t,a){return"".concat(e," wants you to sign in with your Solana account:\n").concat(t,"\n\nYou are proving you own ").concat(t,".\n\nURI: ").concat(r,"\nVersion: 1\nChain ID: mainnet\nNonce: ").concat(a,"\nIssued At: ").concat(new Date().toISOString(),"\nResources:\n- https://privy.io")}function G(){return f(32)}function L(){return a.tw.encode(f(16))}function B(e,r){return er(eo(e),r)}function V(){return crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async function j(e){return new Uint8Array(await crypto.subtle.exportKey("raw",e))}function z(e){return crypto.subtle.importKey("raw",e,"AES-GCM",!0,["encrypt","decrypt"])}async function W(){return await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"])}async function Y(e){return function(e,r){let t=Q(e),a=t.match(/.{1,64}/g),o=a?a.join("\n"):t;return"-----BEGIN ".concat(r,"-----\n")+o+"\n-----END ".concat(r,"-----")}(await crypto.subtle.exportKey("spki",e),"PUBLIC KEY")}async function H(e){return Q(await crypto.subtle.exportKey("pkcs8",e))}function Q(e){return btoa(String.fromCharCode(...new Uint8Array(e)))}async function Z(e){let r=await crypto.subtle.exportKey("raw",e);return await X(r)}async function J(e){let r=eo(e);return await X(r)}async function X(e){return new Uint8Array(await crypto.subtle.digest("SHA-256",e))}async function $(e,r){let t=f(12);return{encryptedShare:await et(e,t,r),encryptedShareIV:t}}function ee(e,r,t){return ea(e,r,t)}async function er(e,r){if(32!==r.byteLength)throw Error("pbkdf2 salt length should be 32 bytes");let t=await crypto.subtle.importKey("raw",e,"PBKDF2",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:r,hash:"SHA-512",iterations:21e5},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async function et(e,r,t){return new Uint8Array(await crypto.subtle.encrypt({iv:r,name:"AES-GCM"},t,e))}async function ea(e,r,t){return new Uint8Array(await crypto.subtle.decrypt({iv:r,name:"AES-GCM"},t,e))}function eo(e){return new TextEncoder().encode(e)}},24895:(e,r,t)=>{"use strict";function a(e){return e.charAt(0).toUpperCase()+e.slice(1)}t.d(r,{Yq:()=>o,Zr:()=>a,j8:()=>n,lM:()=>d,vz:()=>i,yy:()=>s});let o=function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{weekday:"long",year:"numeric",month:"short",day:"numeric"};return new Date(1e3*e).toLocaleDateString("en-us",r)},i=e=>{if(!e)return"";let r=e.slice(0,5),t=e.slice(e.length-4,e.length);return"".concat(r,"...").concat(t)},n=function(e,r){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=new URL(r,e.endsWith("/")?e:"".concat(e,"/"));for(let[e,r]of Object.entries(t))a.searchParams.set(e,r);return a.href},s=(e,r)=>{let t=r?Math.floor(Math.random()*(2*r+1))-r:0;return new Promise(r=>setTimeout(r,e+t))},c=/\.g\.alchemy\.com/i;function d(e){return c.test(e)}},36262:()=>{},8379:()=>{},43167:()=>{},85367:()=>{},76928:()=>{},27976:()=>{}}]);